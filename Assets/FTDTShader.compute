// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#define C 299792458


struct FDTD{
    float3 pos;
    float4 color;
    float coef;
};

RWStructuredBuffer<FDTD> array;

RWStructuredBuffer<FDTD> HFields;
RWStructuredBuffer<FDTD> HUpdated;

RWStructuredBuffer<FDTD> EFields;
RWStructuredBuffer<FDTD> EUpdated;

float time;
float dist;
float resolution;
int version;
float CEx[50][50], CEy[50][50], CEz[50][50];

[numthreads(1,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    for(int x = 0; x < resolution; x++){
        for(int y = 0; y < resolution-1; y++){
            CEx[x][y] = 0;
            CEy[x][y] = 0;
            CEz[x][y] = 0;
        }
    }
    FDTD H = HFields[id.x];
    FDTD E = EFields[id.x];

    float CHx, CHy, CHz;

    //HFIELD
    if(version < 1){
        //////////////////////////////////////////////////////
        // E MODE
        //CEx
        for(int x = 0; x < resolution; x++){
            for(int y = 0; y < resolution-1; y++){
                CEx[x][y] = (EFields[x+((y+1)*resolution)].pos.z-EFields[x+(y*resolution)].pos.z)/dist;
            }
            CEx[x][y] = (0-EFields[x+(y*resolution)].pos.z)/dist;
        }
        //CEy
        for(int y = 0; y < resolution; y++){
            for(int x = 0; x < resolution-1; x++){
                CEy[x][y] = -(EFields[(x+1)+(y*resolution)].pos.z-EFields[x+(y*resolution)].pos.z)/dist;
            }
            CEy[x][y] = -(0-EFields[x+(y*resolution)].pos.z)/dist;
        }

        H.pos.x = H.pos.x + (-(C*time)/H.coef) * CEx[x][y];
        H.pos.y = H.pos.y + ((C*time)/H.coef) * CEy[x][y];
        // H.pos.x = (-(C*time)/H.coef) * CEx;
        // H.pos.y = ((C*time)/H.coef) * CEy;


    }

    //EFIELD
    if(version > 0){
        //////// E MODE ///////////////////////////////////////////////
        bool xOn, yOn = false;

        if((id.x+1)%resolution==0) xOn = true;
        if(floor(id.x/resolution)==resolution-1) yOn = true;

        if(!xOn && !yOn){
            CHz = ((H.pos.y-HFields[id.x-1].pos.x)/dist)-((H.pos.y-HFields[id.x-resolution].pos.y)/dist);
        }
        else if(xOn && !yOn){
            CHz = ((H.pos.y-0)/dist)-((H.pos.y-HFields[id.x-resolution].pos.y)/dist);
        }
        else if(!xOn && yOn){
            CHz = ((H.pos.y-HFields[id.x-1].pos.x)/dist)-((H.pos.y-0)/dist);
        }
        else if(xOn && yOn){
            CHz = ((H.pos.y-0)/dist)-((H.pos.y-0)/dist);
        }

        float Dz = (E.coef*E.pos.z) + (C*time*CHz);
        E.pos.z = (1/E.coef)*(Dz);
    }

    // H.color = float4(clamp(H.pos,0,1),1);
    // E.color = float4(clamp(E.pos,0,1),1);

    HUpdated[id.x] = H;
    EUpdated[id.x] = E;


}
