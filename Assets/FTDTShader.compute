// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#define C 299792458
#define UPDATE_H 0
#define UPDATE_E 1

struct FDTD{
    float3 pos;
    float4 color;
    float coef;
};

RWStructuredBuffer<FDTD> array;

RWStructuredBuffer<FDTD> HFields;

RWStructuredBuffer<FDTD> EFields;

float time;
float dist;
int resolution;
int version;

[numthreads(1,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    FDTD H = HFields[id.x];
    FDTD E = EFields[id.x];
    dist = dist;
    float CEx, CEy, CEz, CHz = 0;

    int xPos = id.x%resolution;
    int yPos = (int)floor((float)id.x/(float)resolution);

    //HFIELD
    if(version < 1){
        //////////////////////////////////////////////////////
        // E MODE

        // CEx
        if(yPos >= resolution-1) {
            CEx = (0 - EFields[xPos+((resolution-1)*resolution)].pos.z)/dist;
            //H.pos.z = 0;
        }
        else {
            CEx = (EFields[xPos+((yPos+1)*resolution)].pos.z-EFields[xPos+(yPos*resolution)].pos.z)/dist;
            //H.pos.z = 1;
        }

        // CEy
        if(xPos >= resolution-1){
            CEy = (0-EFields[xPos+(yPos*resolution)].pos.z)/dist;
            //H.pos.y = 0;
        }
        else{
            CEy = (EFields[(xPos+1)+(yPos*resolution)].pos.z-EFields[xPos+(yPos*resolution)].pos.z)/dist;
            //H.pos.z = 1;
        }
        
        /////////////////////////////////////////////////////////////////
        H.pos.x = H.pos.x + (-(C*time)/H.coef) * CEx;
        H.pos.y = H.pos.y + ((C*time)/H.coef) * CEy;
        

        HFields[xPos+(yPos*resolution)] = H;
    }

    //EFIELD
    if(version > 0){
        //////// E MODE ///////////////////////////////////////////////
        bool xOn, yOn = true;

        if(xPos!=0) xOn = false;
        if(yPos!=0) yOn = false;

        //x & y > 0
        if(!xOn && !yOn){
            if(xPos!=resolution-1){
                CHz = ((HFields[xPos+(yPos*resolution)].pos.y-HFields[(xPos+(yPos*resolution))-1].pos.y)/dist)-((HFields[xPos+(yPos*resolution)].pos.x-HFields[xPos+((yPos-1)*resolution)].pos.x)/dist);
            }
        }
        // x = 0
        else if(xOn && !yOn){
            CHz = ((HFields[yPos*resolution].pos.y-0)/dist)-((HFields[yPos*resolution].pos.x-HFields[(yPos-1)*resolution].pos.x)/dist);
        }
        // y = 0
        else if(!xOn && yOn){
            if(xPos!=resolution-1){
                CHz = ((HFields[xPos].pos.y-HFields[xPos-1].pos.y)/dist)-((HFields[xPos].pos.x-0)/dist);
            }
        }
        // x & y = 0
        else if(xOn && yOn){
            CHz = ((HFields[0].pos.y-0)/dist)-((HFields[0].pos.x-0)/dist);
        }

        float Dz = ((EFields[xPos+(yPos*resolution)].coef) * EFields[xPos+(yPos*resolution)].pos.z) + ((C*time) * CHz);
        E.pos.z = (1/EFields[xPos+(yPos*resolution)].coef)*(Dz);
        EFields[xPos+(yPos*resolution)] = E;
    }

}
